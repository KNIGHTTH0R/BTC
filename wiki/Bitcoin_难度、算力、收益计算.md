***

**difficulty**难度是指与曾经最容易发现一个`block`时相比，现在发现一个`block`的困难程度.  

难度的改变周期是每挖到`2016`个block.  

  
### 难度公式：

```
difficulty = maximum_target / current_target
(target is a 256 bit number)
```

  
### 难度是如何在block中存储的？

每个块存储一个打包（pack）过的十六进制表示的`target`. 这个target能够使用预定义的公式推断出来. 例如，在block中被打包的target为`0x1b0404cb`，那么这个十六进制的`target`即是：
```
0x0404cb * 2**(8*(0x1b - 3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000
```
请注意，这个`0x1b0404cb`是一个有符号数据. 最大的合法值为`0x7fffff`，最小的正的合法值为`0x008000`.  

最高（位）的可能难度被定义为`0x1d00ffff`，它的16进制表示为：
```
0x00ffff * 2**(8*(0x1b - 3)) = 0x00000000FFFF0000000000000000000000000000000000000000000000000000
```

需要注意的是有些矿池经常使用非截断（non-truncated）的targets，它定义了`pool difficulty`为
```
0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
```
所以，以上面的`0x1b0404cb`为例，在block里解析出的难度为：
```
0x00000000FFFF0000000000000000000000000000000000000000000000000000 /
0x00000000000404CB000000000000000000000000000000000000000000000000 
= 16307.420938523983 (bdiff)
```
在某些矿池的计算逻辑里，解析出的难度为：
```
0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF /
0x00000000000404CB000000000000000000000000000000000000000000000000 
= 16307.669773817162 (pdiff)
```
  
以下是以python为例计算难度的示例代码：
```
import decimal, math
l = math.log
e = math.e
 
print 0x00ffff * 2**(8*(0x1d - 3)) / float(0x0404cb * 2**(8*(0x1b - 3)))
print l(0x00ffff * 2**(8*(0x1d - 3)) / float(0x0404cb * 2**(8*(0x1b - 3))))
print l(0x00ffff * 2**(8*(0x1d - 3))) - l(0x0404cb * 2**(8*(0x1b - 3)))
print l(0x00ffff) + l(2**(8*(0x1d - 3))) - l(0x0404cb) - l(2**(8*(0x1b - 3)))
print l(0x00ffff) + (8*(0x1d - 3))*l(2) - l(0x0404cb) - (8*(0x1b - 3))*l(2)
print l(0x00ffff / float(0x0404cb)) + (8*(0x1d - 3))*l(2) - (8*(0x1b - 3))*l(2)
print l(0x00ffff / float(0x0404cb)) + (0x1d - 0x1b)*l(2**8)
```

### 最大难度是什么？

没有最小的target，最大的难度可能粗糙的表示为：`maximum_target / 1`(除以0是不合法的），这是个巨大的数字，约为2的224次方。

真实的最大难度是当current_target=0时，但当真实为0时我们是不可能计算的，当然这种情况也不会发生。

### 难度可能会降低吗？

可能.

### 最小的难度是什么？

当target是最大的被允许的值时，即为最小难度，1.

### 算力(hash rate)和给定难度的相关性

每过2016个块后，难度就会调整，依据是前面发现这2016个块的时间。如果按照期望中的每10分钟计算得到一个block的话，2016个block共需2周。  

如果前面的2016个块花费了超过2周的时间，难度会降低。反之，难度升高。难度的调整多少与之前的2016个块花费时间的起伏成正比。  

为了挖到一个块，计算出的hash值必须要比target小。 hash值是一个在`1 ~ 2的256次方-1`之间的随机数。 
 
难度1的偏移为：
```
0xffff * 2**208
```
难度D的偏移为：
```
(0xffff * 2**208)/D
```
因此，在难度D下，要想挖到一个块，我们需要不断计算hash值，大约要计算的hash个数为：
```
D * 2**256 / (0xffff * 2**208)
```
简化后为：
```
D * 2**48 / 0xffff
```

按照每十分钟产生一个块的策略，在600秒内我们需要计算`(D * 2**48 / 0xffff)`个hash值，这就意味着在计算这2016个块的过程中网络的算力（每秒要计算多少次）为：
```
D * 2**48 / 0xffff / 600
```
简化上面的公式可得：
```
D * 2**32 / 600
```


粗略的来看：  
在难度为1时，这个值为7M每秒.  
在完成此篇文章时，难度为`22012.4941572`，这意味着，在之前的2016个块被发现时，平均的全网算力为：
```
22012.4941572 * 2**32 / 600 = around 157 Ghashes per second.
```


### 如何估算产生一个块的时间？

产生一个块平均需要的时间可以这样估算：
```
time = difficulty * 2**32 / hashrate
```
difficulty是当前难度，hashrate是每秒矿机计算的hash值个数（算力），time是挖掘到bloco的平均间隔时间.  

例如：以python为例，在难度为20000下，我们使用1GHash/s的算力，产生block的时间：
```
$ python -c "print 20000 * 2**32 / 10**9 / 60 / 60.0"
23.85(单位为小时)
```
差不多需要24个小时。